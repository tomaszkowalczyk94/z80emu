package org.tomaszkowalczyk94.z80emu.core.helper;

import org.tomaszkowalczyk94.xbit.XBit8;
import org.tomaszkowalczyk94.z80emu.core.InterruptsManager;
import org.tomaszkowalczyk94.z80emu.core.Z80;

import static org.tomaszkowalczyk94.z80emu.core.register.FlagRegManager.Flag.*;

public class FlagHelper {

    /**
     * The Sign Flag (S) stores the state of the most-significant bit of the Accumulator (bit 7).
     * When the Z80 CPU performs arithmetic operations on signed numbers, the binary twos
     * complement notation is used to represent and process numeric information. A positive
     * number is identified by a 0 in Bit 7. A negative number is identified by a 1. The binary
     * equivalent of the magnitude of a positive number is stored in bits 0 to 6 for a total range of
     * from 0 to 127. A negative number is represented by the twos complement of the equiva
     * lent positive number. The total range for negative numbers is from –1 to –128.
     * When inputting a byte from an I/O device to a register using an IN r, (C) instruction, the S
     * Flag indicates either positive (S = 0) or negative (S = 1) data.
     */
    public void setSignFlagBy8bit(Z80 z80, XBit8 value) {
        z80.getRegs().setFlag(S, value.isNegative());
    }

    /**
     * The Sign Flag (S) stores the state of the most-significant bit of the Accumulator (bit 7).
     * S is set if the A Register is negative; otherwise, it is reset
     */
    public void setSignFlagByA(Z80 z80) {
        setSignFlagBy8bit(z80, z80.getRegs().getA());
    }

    /**
     * The Zero Flag (Z) is set (1) or cleared (0) if the result generated by the execution of certain
     * instructions is 0.
     */
    public void setZeroFlabBy8bit(Z80 z80, XBit8 value) {
        z80.getRegs().setFlag(Z,
                value.getSignedValue() == 0
        );
    }

    /**
     * For 8-bit arithmetic and logical operations, the Z flag is set to a 1
     * the Accumulator is 0. If the byte is not 0, the Z flag is reset to 0.
     */
    public void setZeroFlagByA(Z80 z80) {
        setZeroFlabBy8bit(z80, z80.getRegs().getA());
    }

    /**
     * The Half Carry Flag (H) is set (1) or cleared (0) depending on the Carry and Borrow status
     * between bits 3 and 4 of an 8-bit arithmetic operation. This flag is used by the Decimal
     * Adjust Accumulator (DAA) instruction to correct the result of a packed BCD add or sub
     * tract operation.
     */
    public void setHalfCarryFlagSub(Z80 z80, XBit8 valLeft, XBit8 valRight) {
        int left = valLeft.getSignedValue() & 0x000F;
        int right = valRight.getSignedValue() & 0x000F;
        z80.getRegs().setFlag(H, (left < right));
    }

    /**
     * During the LD A, I and LD A, R instructions, the P/V Flag is set with the value of the
     * interrupt enable flip-flop (IFF2) for storage or testing.
     */
    public void setPvFlagByIff2(Z80 z80) {
        z80.getRegs().setFlag(PV, z80.getInterruptsManager().isIff2());
    }

}
